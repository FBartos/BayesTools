marginal_posterior <- function(samples, parameter, formula = NULL, formula_parameter = NULL, at = NULL, prior_samples = FALSE,
                               transformation = NULL, transformation_arguments = NULL, transformation_settings = FALSE, ...){

  check_list(samples, "prior_list")
  if(any(!sapply(samples, inherits, what = "mixed_posteriors")))
    stop("'samples' must be a be an object generated by 'mix_posteriors' function.")
  check_char(parameter, "parameter", allow_values = names(samples))
  if(!is.null(formula) && !is.language(formula))
    stop("'formula' must be a formula")
  check_char(formula_parameter, "formula_parameter", allow_NULL = TRUE)
  if(!is.null(at) && !is.list(at))
    stop("'at' must be a list")
  .check_transformation_input(transformation, transformation_arguments, transformation_settings)


  # deal formula vs non-formula marginal posterior
  if(inherits(samples[[parameter]], "mixed_posteriors.formula")){

      # remove the specified response (would crash the model.frame if not included)
      formula <- .remove_response(formula)

      # extract the terms information from the formula
      formula_terms          <- stats::terms(formula)
      has_intercept          <- attr(formula_terms, "intercept") == 1
      predictors             <- as.character(attr(formula_terms, "variables"))[-1]
      model_terms            <- c(if(has_intercept) "intercept", attr(formula_terms, "term.labels"))
      BayesTools_model_terms <- BayesTools:::JAGS_parameter_names(parameters = model_terms, formula_parameter = formula_parameter)

      # check that all predictors have samples and data
      if(!all(BayesTools_model_terms %in% names(samples)))
        stop(paste0("The posterior samples for the ", paste0("'", predictors[!model_terms %in% format_parameter_names(names(prior_list_formula), formula_parameters = parameter, formula_prefix = FALSE)], "'", collapse = ", ")," term is missing in the samples."))

      # select the relevant posterior samples
      posterior_samples_matrix <- do.call(cbind, samples[names(samples) %in% BayesTools_model_terms])

      # obtain prior list
      priors_lists <- lapply(BayesTools_model_terms, function(parameter) .simplify_prior_list(attr(samples[[parameter]], "prior_list")))
      names(priors_lists) <- BayesTools_model_terms

      # specify the predictor model matrix


      if(!all(predictors %in% colnames(data)))
        stop(paste0("The ", paste0("'", predictors[!predictors %in% colnames(data)], "'", collapse = ", ")," predictor variable is missing in the data."))





      # # select priors corresponding to the prior distribution
      # prior_parameter <- sapply(prior_list, function(p) if(is.null(attr(p, "parameter"))) "__none" else attr(p, "parameter"))
      # if(!any(parameter %in% unique(prior_parameter)))
      #   stop("The specified parameter '", parameter, "' was not used in any of the prior distributions.")
      # prior_list_formula <- prior_list[prior_parameter == parameter]
      # names(prior_list_formula) <- format_parameter_names(names(prior_list_formula), formula_parameters = parameter, formula_prefix = FALSE)
      #
      #
      #
      # # obtain predictors characteristics -- based on prior distributions used to fit the original model
      # # (i.e., do not truest the supplied data -- probably passed by the user)
      # model_terms_type <- sapply(model_terms, function(model_term){
      #   if(model_term == "intercept"){
      #     return("continuous")
      #   }else if(is.prior.factor(prior_list_formula[[model_term]])){
      #     return("factor")
      #   }else if(is.prior.simple(prior_list_formula[[model_term]])){
      #     return("continuous")
      #   }
      # })
      # predictors_type <- model_terms_type[predictors]
      #
      # # check that passed data correspond to the specified priors (factor levels etc...) and set the proper contrasts
      # if(any(predictors_type == "factor")){
      #
      #   # check the proper data input for each factor prior
      #   for(factor in names(predictors_type[predictors_type == "factor"])){
      #
      #     # select the corresponding prior in the variable
      #     if(is.prior.spike_and_slab(prior_list_formula[[factor]])){
      #       this_prior <- prior_list_formula[[factor]][["variable"]]
      #     }else{
      #       this_prior <- prior_list_formula[[factor]]
      #     }
      #
      #     if(is.factor(data[,factor])){
      #       if(all(levels(data[,factor]) %in% .get_prior_factor_level_names(this_prior))){
      #         # either the formatting is correct, or the supplied levels are a subset of the original levels
      #         # reformat to check ordering and etc...
      #         data[,factor] <- factor(data[,factor], levels = .get_prior_factor_level_names(this_prior))
      #       }else{
      #         # there are some additional levels
      #         stop(paste0("Levels specified in the '", factor, "' factor variable do not match the levels used for model specification."))
      #       }
      #     }else if(all(unique(data[,factor]) %in% .get_prior_factor_level_names(this_prior))){
      #       # the variable was not passed as a factor but the values matches the factor levels
      #       data[,factor] <- factor(data[,factor], levels = .get_prior_factor_level_names(this_prior))
      #     }else{
      #       # there are some additional mismatching values
      #       stop(paste0("Levels specified in the '", factor, "' factor variable do not match the levels used for model specification."))
      #     }
      #   }
      #
      #   # set the contrast
      #   if(is.prior.orthonormal(this_prior)){
      #     stats::contrasts(data[,factor]) <- "contr.orthonormal"
      #   }else if(is.prior.meandif(this_prior)){
      #     stats::contrasts(data[,factor]) <- "contr.meandif"
      #   }else if(is.prior.independent(this_prior)){
      #     stats::contrasts(data[,factor]) <- "contr.independent"
      #   }else if(is.prior.treatment(this_prior)){
      #     stats::contrasts(data[,factor]) <- "contr.treatment"
      #   }
      # }
      # if(any(predictors_type == "continuous")){
      #
      #   # check the proper data input for each continuous prior
      #   for(continuous in names(predictors_type[predictors_type == "continuous"])){
      #
      #     # select the corresponding prior in the variable
      #     if(is.prior.spike_and_slab(prior_list_formula[[continuous]])){
      #       this_prior <- prior_list_formula[[continuous]][["variable"]]
      #     }else{
      #       this_prior <- prior_list_formula[[continuous]]
      #     }
      #
      #     if(is.prior.factor(this_prior)){
      #       stop(paste0("Unsupported prior distribution defined for '", continuous, "' continuous variable. See '?prior' for details."))
      #     }
      #   }
      # }
      #
      # # get the design matrix
      # model_frame  <- stats::model.frame(formula, data = data)
      # model_matrix <- stats::model.matrix(model_frame, formula = formula, data = data)
      #
      # ### evaluate the design matrix on the samples -> output[data, posterior]
      # if(has_intercept){
      #   terms_indexes    <- attr(model_matrix, "assign") + 1
      #   terms_indexes[1] <- 0
      #
      #   output           <- matrix(posterior[,JAGS_parameter_names("intercept", formula_parameter = parameter)], nrow = nrow(data), ncol = nrow(posterior), byrow = TRUE)
      # }else{
      #   terms_indexes    <- attr(model_matrix, "assign")
      #
      #   output           <- matrix(0, nrow = nrow(data), ncol = nrow(posterior))
      # }
      #
      # # add remaining terms (omitting the intercept indexed as NA)
      # for(i in unique(terms_indexes[terms_indexes > 0])){
      #
      #   # check for scaling factors
      #   if(!is.null(attr(prior_list_formula[[model_terms[i]]], "multiply_by"))){
      #     if(is.numeric(attr(prior_list_formula[[model_terms[i]]], "multiply_by"))){
      #       temp_multiply_by <- matrix(attr(prior_list_formula[[model_terms[i]]], "multiply_by"), nrow = nrow(data), ncol = nrow(posterior))
      #     }else{
      #       temp_multiply_by <- matrix(posterior[,JAGS_parameter_names(attr(prior_list_formula[[model_terms[i]]], "multiply_by"))], nrow = nrow(data), ncol = nrow(posterior), byrow = TRUE)
      #     }
      #   }else{
      #     temp_multiply_by <- matrix(1, nrow = nrow(data), ncol = nrow(posterior))
      #   }
      #
      #
      #   # subset the model matrix
      #   temp_data    <- model_matrix[,terms_indexes == i,drop = FALSE]
      #
      #   # get the posterior (unless point prior was used)
      #   if(is.prior.point(prior_list_formula[[model_terms[i]]])){
      #     temp_posterior <- matrix(
      #       prior_list_formula[[model_terms[i]]]$parameters[["location"]],
      #       nrow = nrow(posterior),
      #       ncol = if(model_terms_type[i] == "factor") .get_prior_factor_levels(prior_list_formula[[model_terms[i]]]) else 1
      #     )
      #   }else{
      #     temp_posterior <- posterior[,paste0(
      #       JAGS_parameter_names(model_terms[i], formula_parameter = parameter),
      #       if(model_terms_type[i] == "factor" && .get_prior_factor_levels(prior_list_formula[[model_terms[i]]]) > 1) paste0("[", 1:.get_prior_factor_levels(prior_list_formula[[model_terms[i]]]), "]"))
      #       ,drop = FALSE]
      #   }
      #
      #   output <- output + temp_multiply_by * (temp_data %*% t(temp_posterior))
      #
      # }



  }else{

    if(!is.null(formula))
      stop("'formula' is supposed to be NULL when dealing with simple posteriors")
    if(!is.null(data))
      stop("'data' is supposed to be NULL when dealing with simple posteriors")

    # extract the corresponding samples
    if(inherits(samples[[parameter]], "mixed_posteriors.factor")){

      posterior_samples <- transform_factor_samples(samples[parameter])
      posterior_samples <- transform_treatment_samples(samples[parameter])[[parameter]]
      class(posterior_samples) <- c(class(posterior_samples), "marginal_posteriors.factor")

    }else if(inherits(samples[[parameter]], "mixed_posteriors.simple")){

      posterior_samples <- samples[[parameter]]
      class(posterior_samples) <- c(class(posterior_samples), "marginal_posteriors.simple")

    }

    # apply transformations
    if(!is.null(transformation)){
      posterior_samples <- .density.prior_transformation_x(posterior_samples, transformation, transformation_arguments)
    }


    # add prior samples
    if(prior_samples){

      prior_list  <- attr(samples[[parameter]], "prior_list")
      prior_list  <- .simplify_prior_list(prior_list)

      plot_data_prior <- .plot_data_prior_list.simple(prior_list, x_seq = NULL, x_range = NULL, x_range_quant = NULL,
                                                      n_points = 101, n_samples = 10000, force_samples = TRUE, individual = FALSE,
                                                      transformation = transformation, transformation_arguments = transformation_arguments,
                                                      transformation_settings = transformation_settings)

      # the complete samples are added to each output object & add the corresponding attributes
      prior_samples <- plot_data_prior[[1]]$samples
      attributes(prior_samples) <- c(attributes(prior_samples), attributes(samples[[parameter]])[!names(attributes(samples[[parameter]])) %in% names(attributes(prior_samples))])

      # transform if factors
      if(inherits(samples[[parameter]], "mixed_posteriors.factor")){

        prior_samples <- transform_factor_samples(list(prior_samples))
        prior_samples <- transform_treatment_samples(prior_samples)[[1]]
        class(prior_samples) <- c(class(prior_samples), "marginal_posteriors.factor")

      }else if(inherits(samples[[parameter]], "mixed_posteriors.simple")){

        class(prior_samples) <- c(class(prior_samples), "marginal_posteriors.simple")

      }

      # add to the posterior samples
      attr(posterior_samples, "prior_samples") <- prior_samples

    }
  }

  return(posterior_samples)
}
